function mergeDIVs(divFolders, outputFolder, varargin)
%% MERGEDIVS Merge spike data from multiple DIV output folders
%
% This function merges spike detection results from multiple DIV output folders
% generated by MEA-NAP pipeline. It focuses specifically on combining data after 
% Step 1 (spike detection) to enable further analysis of developmental trajectories.
%
% USAGE:
%   mergeDIVs(divFolders, outputFolder)
%   mergeDIVs(divFolders, outputFolder, options)
%
% INPUTS:
%   divFolders      - Cell array of strings with paths to DIV folders
%   outputFolder    - String, path to save the merged output
%   options         - (Optional) Struct with the following possible fields:
%       .overwrite          - Logical, whether to overwrite existing output (default: false)
%       .verbose            - Logical, whether to display detailed information (default: true)
%       .mergeExperiments   - Logical, whether to merge experiment mat files (default: true)
%       .copySpikes         - Logical, whether to copy spike files (default: true)
%       .mergeDivCSVs       - Logical, whether to merge DIV CSV files (default: true)
%
% OUTPUTS:
%   Creates a merged output folder containing:
%   - Combined spike detection data
%   - Merged DIV CSV file
%   - Unified parameter files
%   - Experiment mat files
%
% This function assumes that all input folders contain spike detection results
% from MEA-NAP and that the recordings were made on the same type of MEA grid.
%
% EXAMPLES:
%   % Merge two DIV folders
%   divFolders = {'/path/to/DIV5/div5', '/path/to/DIV10/div10'};
%   outputFolder = '/path/to/output/MergedDIVs';
%   mergeDIVs(divFolders, outputFolder);
%
%   % Merge with custom options
%   options.overwrite = true;
%   options.verbose = true;
%   mergeDIVs(divFolders, outputFolder, options);
%
% Author: Avinash

%% Parse input arguments
if nargin < 2
    error('Not enough input arguments. At least divFolders and outputFolder must be specified.');
end

% Set default options
options = struct(...
    'overwrite', false, ...
    'verbose', true, ...
    'mergeExperiments', true, ...
    'copySpikes', true, ...
    'mergeDivCSVs', true);

% Override defaults with user specified options
if nargin > 2
    userOptions = varargin{1};
    if ~isstruct(userOptions)
        error('Options must be provided as a struct.');
    end
    
    fields = fieldnames(userOptions);
    for i = 1:length(fields)
        if isfield(options, fields{i})
            options.(fields{i}) = userOptions.(fields{i});
        else
            warning('Unknown option: %s', fields{i});
        end
    end
end

% Ensure divFolders is a cell array
if ~iscell(divFolders)
    divFolders = {divFolders};
end

%% Initial validation
% Display function header
if options.verbose
    fprintf('=================================================\n');
    fprintf('MEA-NAP DIV Spike Data Merger\n');
    fprintf('=================================================\n\n');
    fprintf('Starting merge of %d DIV folders...\n', length(divFolders));
end

% Check if output folder exists
if exist(outputFolder, 'dir')
    if ~options.overwrite
        error('Output folder already exists. Use options.overwrite=true to overwrite.');
    elseif options.verbose
        fprintf('Output folder exists and will be overwritten.\n');
    end
else
    % Create output folder
    if options.verbose
        fprintf('Creating output folder: %s\n', outputFolder);
    end
    mkdir(outputFolder);
end

% Validate input folders
validFolders = {};
divNumbers = zeros(1, length(divFolders));

for i = 1:length(divFolders)
    % Check if folder exists
    if ~exist(divFolders{i}, 'dir')
        warning('Folder does not exist: %s - skipping', divFolders{i});
        continue;
    end
    
    % Check for spike detection folder
    spikeFolder = fullfile(divFolders{i}, '1_SpikeDetection');
    spikeDataFolder = fullfile(spikeFolder, '1A_SpikeDetectedData');
    if ~exist(spikeDataFolder, 'dir')
        warning('No spike data folder found in: %s - skipping', divFolders{i});
        continue;
    end
    
    % Check for parameter file
    paramFiles = dir(fullfile(divFolders{i}, 'Parameters_*.mat'));
    if isempty(paramFiles)
        warning('No parameter file found in: %s - skipping', divFolders{i});
        continue;
    end
    
    % Try to extract DIV number from folder name or DIV CSV file
    divCSV = dir(fullfile(divFolders{i}, 'div*.csv'));
    if ~isempty(divCSV)
        % Extract DIV number from CSV filename
        divMatch = regexp(divCSV(1).name, 'div(\d+)', 'tokens');
        if ~isempty(divMatch) && ~isempty(divMatch{1})
            divNumbers(i) = str2double(divMatch{1}{1});
        else
            % Try to extract from folder name
            [~, folderName] = fileparts(divFolders{i});
            divMatch = regexp(folderName, '(DIV|div)(\d+)', 'tokens');
            if ~isempty(divMatch) && ~isempty(divMatch{1})
                if length(divMatch{1}) > 1
                    divNumbers(i) = str2double(divMatch{1}{2}); % Get the number part
                else
                    divNumbers(i) = str2double(regexprep(divMatch{1}{1}, 'DIV|div', ''));
                end
            else
                divNumbers(i) = i; % Default sequential numbering
            end
        end
    else
        % Try folder name if no CSV
        [~, folderName] = fileparts(divFolders{i});
        divMatch = regexp(folderName, '(DIV|div)(\d+)', 'tokens');
        if ~isempty(divMatch) && ~isempty(divMatch{1})
            if length(divMatch{1}) > 1
                divNumbers(i) = str2double(divMatch{1}{2}); % Get the number part
            else
                divNumbers(i) = str2double(regexprep(divMatch{1}{1}, 'DIV|div', ''));
            end
        else
            divNumbers(i) = i; % Default sequential numbering
        end
    end
    
    validFolders{end+1} = divFolders{i};
    if options.verbose
        fprintf('✓ Validated folder: %s (DIV %d)\n', divFolders{i}, divNumbers(i));
    end
end

% Check if we have any valid folders
if isempty(validFolders)
    error('No valid DIV folders found. Please check your input folders.');
end

% Sort folders by DIV number
[divNumbers, sortIdx] = sort(divNumbers(1:length(validFolders)));
validFolders = validFolders(sortIdx);

if options.verbose
    fprintf('\nProcessing folders in DIV order:\n');
    for i = 1:length(validFolders)
        fprintf('  DIV %d: %s\n', divNumbers(i), validFolders{i});
    end
    fprintf('\n');
end

%% Create output folder structure
% Create spike detection folders
spikeOutputFolder = fullfile(outputFolder, '1_SpikeDetection');
spikeDataOutputFolder = fullfile(spikeOutputFolder, '1A_SpikeDetectedData');
spikeChecksOutputFolder = fullfile(spikeOutputFolder, '1B_SpikeDetectionChecks');

if ~exist(spikeOutputFolder, 'dir')
    mkdir(spikeOutputFolder);
end
if ~exist(spikeDataOutputFolder, 'dir')
    mkdir(spikeDataOutputFolder);
end
if ~exist(spikeChecksOutputFolder, 'dir')
    mkdir(spikeChecksOutputFolder);
end

% Create ExperimentMatFiles folder
experimentMatFolder = fullfile(outputFolder, 'ExperimentMatFiles');
if ~exist(experimentMatFolder, 'dir')
    mkdir(experimentMatFolder);
end

%% Copy spike data files
if options.copySpikes
    if options.verbose
        fprintf('Copying spike data files...\n');
    end
    
    spikeFileCounter = 0;
    
    for i = 1:length(validFolders)
        sourceFolder = fullfile(validFolders{i}, '1_SpikeDetection', '1A_SpikeDetectedData');
        spikeFiles = dir(fullfile(sourceFolder, '*_spikes.mat'));
        
        for j = 1:length(spikeFiles)
            copyfile(fullfile(sourceFolder, spikeFiles(j).name), ...
                    fullfile(spikeDataOutputFolder, spikeFiles(j).name));
            spikeFileCounter = spikeFileCounter + 1;
        end
        
        % Also copy spike detection check folders if they exist
        sourceChecksFolder = fullfile(validFolders{i}, '1_SpikeDetection', '1B_SpikeDetectionChecks');
        if exist(sourceChecksFolder, 'dir')
            % Get all subdirectories (group folders)
            groupFolders = dir(sourceChecksFolder);
            groupFolders = groupFolders([groupFolders.isdir]);
            groupFolders = groupFolders(~ismember({groupFolders.name}, {'.', '..'}));
            
            for j = 1:length(groupFolders)
                groupName = groupFolders(j).name;
                targetGroupFolder = fullfile(spikeChecksOutputFolder, groupName);
                
                if ~exist(targetGroupFolder, 'dir')
                    mkdir(targetGroupFolder);
                end
                
                % Copy recording folders for this group
                recordingFolders = dir(fullfile(sourceChecksFolder, groupName));
                recordingFolders = recordingFolders([recordingFolders.isdir]);
                recordingFolders = recordingFolders(~ismember({recordingFolders.name}, {'.', '..'}));
                
                for k = 1:length(recordingFolders)
                    recordingName = recordingFolders(k).name;
                    sourceRecFolder = fullfile(sourceChecksFolder, groupName, recordingName);
                    targetRecFolder = fullfile(spikeChecksOutputFolder, groupName, recordingName);
                    
                    if ~exist(targetRecFolder, 'dir')
                        mkdir(targetRecFolder);
                        
                        % Copy all check images
                        checkImages = dir(fullfile(sourceRecFolder, '*.png'));
                        for img = 1:length(checkImages)
                            copyfile(fullfile(sourceRecFolder, checkImages(img).name), targetRecFolder);
                        end
                    end
                end
            end
        end
    end
    
    if options.verbose
        fprintf('✓ Copied %d spike data files\n', spikeFileCounter);
    end
end

%% Merge DIV CSV files
if options.mergeDivCSVs
    if options.verbose
        fprintf('\nMerging DIV CSV files...\n');
    end
    
    % Collect all CSV data
    allCSVData = {};
    for i = 1:length(validFolders)
        divCSV = dir(fullfile(validFolders{i}, 'div*.csv'));
        if ~isempty(divCSV)
            try
                data = readtable(fullfile(validFolders{i}, divCSV(1).name));
                
                % Add DIV column if not present
                if ~any(strcmpi(data.Properties.VariableNames, 'DIV'))
                    if divNumbers(i) > 0
                        data.DIV = repmat(divNumbers(i), height(data), 1);
                    end
                end
                
                allCSVData{end+1} = data;
            catch ME
                warning('Error reading CSV file %s: %s', divCSV(1).name, ME.message);
            end
        end
    end
    
    % Combine all tables
    if ~isempty(allCSVData)
        % Find common column names across all tables
        allVarNames = cellfun(@(x) x.Properties.VariableNames, allCSVData, 'UniformOutput', false);
        commonVarNames = allVarNames{1};
        
        for i = 2:length(allVarNames)
            commonVarNames = intersect(commonVarNames, allVarNames{i});
        end
        
        % Select only common columns
        for i = 1:length(allCSVData)
            allCSVData{i} = allCSVData{i}(:, commonVarNames);
        end
        
        % Combine tables
        combinedCSV = vertcat(allCSVData{:});
        
        % Sort by DIV if present
        if any(strcmpi(combinedCSV.Properties.VariableNames, 'DIV'))
            combinedCSV = sortrows(combinedCSV, 'DIV');
        end
        
        % Generate output filename
        csvOutputFile = fullfile(outputFolder, 'div_merged.csv');
        
        % Check if we need to match the original folder's CSV header format
        % First check if we can find the format from any source folder
        originalHeaderFormat = 'standard'; % Default format
        for i = 1:length(validFolders)
            divCSV = dir(fullfile(validFolders{i}, 'div*.csv'));
            if ~isempty(divCSV)
                try
                    % Read first line to get header
                    fid = fopen(fullfile(validFolders{i}, divCSV(1).name), 'r');
                    if fid ~= -1
                        headerLine = fgetl(fid);
                        fclose(fid);
                        
                        % Check header format
                        if contains(headerLine, 'Recording filename')
                            originalHeaderFormat = 'recording_format';
                            break;
                        end
                    end
                catch
                    % If error, continue with next folder
                    if fid ~= -1
                        fclose(fid);
                    end
                end
            end
        end
        
        % Handle different formats based on detected format
        if strcmp(originalHeaderFormat, 'recording_format')
            % This matches the merger3855_nap format with "Recording filename,DIV group,Genotype,Ground"
            % The columns are already in the right order, just need to rename
            combinedCSV.Properties.VariableNames{1} = 'Recording filename';
            combinedCSV.Properties.VariableNames{2} = 'DIV';
            combinedCSV.Properties.VariableNames{3} = 'group';
            if any(strcmpi(combinedCSV.Properties.VariableNames, 'ground'))
                combinedCSV.Properties.VariableNames{strcmpi(combinedCSV.Properties.VariableNames, 'ground')} = 'Ground';
            else
                combinedCSV.Ground = repmat({''},height(combinedCSV),1);
            end
            
            % Set Genotype column if it exists
            if any(strcmpi(combinedCSV.Properties.VariableNames, 'Genotype'))
                % Already has Genotype column
            elseif any(strcmpi(combinedCSV.Properties.VariableNames, 'group'))
                % Use group as Genotype
                columnIdx = find(strcmpi(combinedCSV.Properties.VariableNames, 'group'));
                combinedCSV.Properties.VariableNames{columnIdx} = 'Genotype';
            end
            
            % Reorder columns to match expected format
            expectedCols = {'Recording filename', 'DIV', 'Genotype', 'Ground'};
            availableCols = intersect(expectedCols, combinedCSV.Properties.VariableNames, 'stable');
            otherCols = setdiff(combinedCSV.Properties.VariableNames, expectedCols, 'stable');
            combinedCSV = combinedCSV(:, [availableCols, otherCols]);
        else
            % Standard format with filename, DIV, group, ground
            if ~any(strcmpi(combinedCSV.Properties.VariableNames, 'ground'))
                combinedCSV.ground = repmat({''},height(combinedCSV),1);
            end
            
            % Reorder columns
            orderedCols = {'filename', 'DIV', 'group', 'ground'};
            availableCols = intersect(orderedCols, combinedCSV.Properties.VariableNames, 'stable');
            otherCols = setdiff(combinedCSV.Properties.VariableNames, orderedCols, 'stable');
            combinedCSV = combinedCSV(:, [availableCols, otherCols]);
            
            % Rename columns if needed to match expected names
            targetNames = {'filename', 'DIV', 'group', 'ground'};
            currentNames = combinedCSV.Properties.VariableNames(1:min(4,width(combinedCSV)));
            for i = 1:length(currentNames)
                if ~strcmpi(currentNames{i}, targetNames{i})
                    combinedCSV.Properties.VariableNames{i} = targetNames{i};
                end
            end
            
            % Add RecordingFilename column if it doesn't exist
            if ~any(strcmpi(combinedCSV.Properties.VariableNames, 'RecordingFilename'))
                % Try to extract recording name from filename
                if any(strcmpi(combinedCSV.Properties.VariableNames, 'filename'))
                    combinedCSV.RecordingFilename = combinedCSV.filename;
                end
            end
        end
        
        % Write to CSV
        writetable(combinedCSV, csvOutputFile);
        
        if options.verbose
            fprintf('✓ Created merged CSV file: %s\n', csvOutputFile);
            fprintf('  Contains %d recordings across %d DIV timepoints\n', ...
                height(combinedCSV), length(unique(combinedCSV.DIV)));
        end
    else
        warning('No DIV CSV files found to merge.');
    end
end

%% Generate parameter files
if options.verbose
    fprintf('\nGenerating parameter files...\n');
end

% Get output folder name for file naming
[~, outputFolderName] = fileparts(outputFolder);
if isempty(outputFolderName)
    outputFolderName = 'MergedDIVs';
end

%% Merge Parameter Files

% Load all parameter files
allParams = cell(1, length(validFolders));
for i = 1:length(validFolders)
    paramFiles = dir(fullfile(validFolders{i}, 'Parameters_*.mat'));
    if ~isempty(paramFiles)
        paramData = load(fullfile(validFolders{i}, paramFiles(1).name));
        if isfield(paramData, 'Params')
            allParams{i} = paramData.Params;
        else
            warning('Parameters not found in %s - skipping', paramFiles(1).name);
        end
    end
end

% Start with the first one as the base
if ~isempty(allParams) && ~isempty(allParams{1})
    Params = allParams{1};
    
    % Update folder-specific information
    Params.outputDataFolder = outputFolder;
    Params.outputDataFolderName = outputFolderName;
    Params.DivNm = divNumbers;
    Params.spikeDetectedData = ''; 
    Params.startAnalysisStep = 1;
    Params.rawData = '';
    Params.guiMode = 0;
    Params.HomeDir = fileparts(mfilename('fullpath'));
    
    % Set spreadSheetFileName to the merged CSV
    divCsvPath = fullfile(outputFolder, 'div_merged.csv');
    if exist(divCsvPath, 'file')
        Params.spreadSheetFileName = divCsvPath;
    end
    
    % Save the merged MAT file
    paramMatFile = fullfile(outputFolder, ['Parameters_' outputFolderName '.mat']);
    save(paramMatFile, 'Params');
    
    % Create the CSV file using all parameter files to ensure all fields are captured
    % This part will focus on merging channel and coordinate data correctly
    
    % First, collect all channel and coordinate data from all parameter files
    allChannelData = {};
    allCoordData = {};
    
    for i = 1:length(validFolders)
        % Load the CSV parameter file
        paramCSVFiles = dir(fullfile(validFolders{i}, 'Parameters_*.csv'));
        if ~isempty(paramCSVFiles)
            try
                % Read the CSV file keeping original variable names
                opts = detectImportOptions(fullfile(validFolders{i}, paramCSVFiles(1).name));
                opts.PreserveVariableNames = true;
                T = readtable(fullfile(validFolders{i}, paramCSVFiles(1).name), opts);
                
                % Find all channel and coordinate columns
                colNames = T.Properties.VariableNames;
                channelCols = {};
                coordCols = {};
                
                for j = 1:length(colNames)
                    if strncmp(colNames{j}, 'channels_', 9)
                        channelCols{end+1} = colNames{j};
                    elseif strncmp(colNames{j}, 'coords_', 7)
                        coordCols{end+1} = colNames{j};
                    end
                end
                
                % Store the columns and their data
                allChannelData{end+1} = {T, channelCols};
                allCoordData{end+1} = {T, coordCols};
                
                if options.verbose
                    fprintf('  Found %d channel and %d coordinate columns in %s\n', ...
                        length(channelCols), length(coordCols), validFolders{i});
                end
            catch ME
                warning('Could not read parameter CSV file from %s: %s', validFolders{i}, ME.message);
            end
        end
    end
    
    % Create a new struct for the CSV export
    % This will contain all fields from the original parameter files
    tableStruct = struct();
    
    % First, convert the Params struct to a basic structure for the CSV
    paramFields = fieldnames(Params);
    for i = 1:length(paramFields)
        fieldName = paramFields{i};
        if ~strcmp(fieldName, 'channels') && ~strcmp(fieldName, 'coords')
            % Handle standard fields
            if isstruct(Params.(fieldName))
                % Expand struct fields with _ separator
                subfields = fieldnames(Params.(fieldName));
                for j = 1:length(subfields)
                    if isscalar(Params.(fieldName).(subfields{j}))
                        tableStruct.([fieldName '_' subfields{j}]) = Params.(fieldName).(subfields{j});
                    end
                end
            elseif iscell(Params.(fieldName))
                % Handle cell arrays - make them indexed fields
                for j = 1:length(Params.(fieldName))
                    if j <= length(Params.(fieldName))
                        if ischar(Params.(fieldName){j})
                            tableStruct.([fieldName '_' num2str(j)]) = Params.(fieldName){j};
                        elseif isnumeric(Params.(fieldName){j}) && isscalar(Params.(fieldName){j})
                            tableStruct.([fieldName '_' num2str(j)]) = Params.(fieldName){j};
                        end
                    end
                end
            elseif isnumeric(Params.(fieldName)) && length(Params.(fieldName)) > 1
                % Handle numeric arrays - make them indexed fields
                for j = 1:length(Params.(fieldName))
                    tableStruct.([fieldName '_' num2str(j)]) = Params.(fieldName)(j);
                end
            else
                % Handle scalar values
                tableStruct.(fieldName) = Params.(fieldName);
            end
        end
    end
    
    % Now, create a complete set of channel and coordinate fields
    % Merge from all parameter files, ensuring none are missed
    
    % Initialize default values
    % First get the maximum indices for channels and coords from all folders
    maxChannelRow = 0;
    maxChannelCol = 0;
    maxCoordRow = 0;
    maxCoordCol = 0;
    
    % Pattern for extracting row and column from field names like "channels_1_2" or "coords_3_4"
    channelPattern = 'channels_(\d+)_(\d+)';
    coordPattern = 'coords_(\d+)_(\d+)';
    
    % Scan through all parameter files to find the maximum indices
    for i = 1:length(allChannelData)
        if ~isempty(allChannelData{i})
            channelCols = allChannelData{i}{2};
            for j = 1:length(channelCols)
                tokens = regexp(channelCols{j}, channelPattern, 'tokens');
                if ~isempty(tokens) && ~isempty(tokens{1})
                    row = str2double(tokens{1}{1});
                    col = str2double(tokens{1}{2});
                    maxChannelRow = max(maxChannelRow, row);
                    maxChannelCol = max(maxChannelCol, col);
                end
            end
        end
    end
    
    for i = 1:length(allCoordData)
        if ~isempty(allCoordData{i})
            coordCols = allCoordData{i}{2};
            for j = 1:length(coordCols)
                tokens = regexp(coordCols{j}, coordPattern, 'tokens');
                if ~isempty(tokens) && ~isempty(tokens{1})
                    row = str2double(tokens{1}{1});
                    col = str2double(tokens{1}{2});
                    maxCoordRow = max(maxCoordRow, row);
                    maxCoordCol = max(maxCoordCol, col);
                end
            end
        end
    end
    
    % Ensure we have at least 48 rows for channels
    maxChannelRow = max(maxChannelRow, 48);
    maxChannelCol = max(maxChannelCol, 16);
    maxCoordRow = max(maxCoordRow, 48);
    maxCoordCol = max(maxCoordCol, 32);
    
    % Initialize all channel fields with default values
    for i = 1:maxChannelRow
        for j = 1:maxChannelCol
            tableStruct.(['channels_' num2str(i) '_' num2str(j)]) = 0;
        end
    end
    
    % Initialize all coordinate fields with default values
    % For X coordinates (j <= 16)
    for i = 1:maxCoordRow
        for j = 1:16
            tableStruct.(['coords_' num2str(i) '_' num2str(j)]) = (j-1) * 2.66666666666667;
        end
    end
    
    % For Y coordinates (j > 16)
    for i = 1:maxCoordRow
        for j = 17:maxCoordCol
            tableStruct.(['coords_' num2str(i) '_' num2str(j)]) = (i-1) * 2.66666666666667;
        end
    end
    
    % Now overlay the actual data from all parameter files
    % We'll process them in DIV order, so later DIVs override earlier ones if there's a conflict
    
    % First, prepare a mapping of DIV folders to their row indices in the parameter file
    divToRowIndices = containers.Map('KeyType', 'double', 'ValueType', 'any');
    
    % The default is to map DIV1 to rows 1-24, DIV2 to rows 25-48, etc.
    rowsPerDIV = min(24, floor(maxChannelRow / length(divNumbers)));
    
    % Create the mapping
    for divIdx = 1:length(divNumbers)
        divToRowIndices(divNumbers(divIdx)) = ((divIdx-1) * rowsPerDIV + 1):(divIdx * rowsPerDIV);
    end
    
    % Now overlay each DIV's data to its corresponding rows
    for folderIdx = 1:length(validFolders)
        if ~isempty(allChannelData{folderIdx}) && ~isempty(allCoordData{folderIdx})
            div = divNumbers(folderIdx);
            rowIndices = divToRowIndices(div);
            
            % Get the channel and coordinate data for this DIV
            channelData = allChannelData{folderIdx}{1};
            channelCols = allChannelData{folderIdx}{2};
            
            coordData = allCoordData{folderIdx}{1};
            coordCols = allCoordData{folderIdx}{2};
            
            % Map this DIV's channels to the appropriate rows in our final structure
            for j = 1:length(channelCols)
                % Extract row and column from field name
                tokens = regexp(channelCols{j}, channelPattern, 'tokens');
                if ~isempty(tokens) && ~isempty(tokens{1})
                    sourceRow = str2double(tokens{1}{1});
                    col = str2double(tokens{1}{2});
                    
                    % Map source row to target row using modulo arithmetic
                    % to handle the case where the source has more rows than rowsPerDIV
                    localRowIdx = mod(sourceRow - 1, length(rowIndices)) + 1;
                    targetRow = rowIndices(localRowIdx);
                    
                    % Create the target field name
                    targetField = ['channels_' num2str(targetRow) '_' num2str(col)];
                    
                    % Get the value from the source
                    if ismember(channelCols{j}, channelData.Properties.VariableNames)
                        tableStruct.(targetField) = channelData.(channelCols{j})(1);
                    end
                end
            end
            
            % Map this DIV's coordinates to the appropriate rows
            for j = 1:length(coordCols)
                % Extract row and column from field name
                tokens = regexp(coordCols{j}, coordPattern, 'tokens');
                if ~isempty(tokens) && ~isempty(tokens{1})
                    sourceRow = str2double(tokens{1}{1});
                    col = str2double(tokens{1}{2});
                    
                    % Map source row to target row
                    localRowIdx = mod(sourceRow - 1, length(rowIndices)) + 1;
                    targetRow = rowIndices(localRowIdx);
                    
                    % Create the target field name
                    targetField = ['coords_' num2str(targetRow) '_' num2str(col)];
                    
                    % Get the value from the source
                    if ismember(coordCols{j}, coordData.Properties.VariableNames)
                        tableStruct.(targetField) = coordData.(coordCols{j})(1);
                    end
                end
            end
        end
    end
    
    % Create table and write to CSV
    paramTable = struct2table(tableStruct, 'AsArray', true);
    paramCSVFile = fullfile(outputFolder, ['Parameters_' outputFolderName '.csv']);
    writetable(paramTable, paramCSVFile);
    
    if options.verbose
        fprintf('✓ Successfully created parameter files\n');
        fprintf('  MAT file: %s\n', paramMatFile);
        fprintf('  CSV file: %s\n', paramCSVFile);
    end
else
    warning('Could not find a valid parameter file in any of the input folders.');
end

%% Copy channel layout file
% Copy the first available channel_layout.png file
for i = 1:length(validFolders)
    layoutFile = fullfile(validFolders{i}, 'channel_layout.png');
    if exist(layoutFile, 'file')
        copyfile(layoutFile, fullfile(outputFolder, 'channel_layout.png'));
        if options.verbose
            fprintf('✓ Copied channel layout file\n');
        end
        break;
    end
end

%% Create experiment mat files
if options.mergeExperiments
    if options.verbose
        fprintf('\nCreating experiment mat files...\n');
    end
    
    % First check if source folders have ExperimentMatFiles
    hasExpMatFiles = false;
    
    for i = 1:length(validFolders)
        sourceExpFolder = fullfile(validFolders{i}, 'ExperimentMatFiles');
        if exist(sourceExpFolder, 'dir')
            hasExpMatFiles = true;
            matFiles = dir(fullfile(sourceExpFolder, '*.mat'));
            
            if options.verbose
                fprintf('  Found ExperimentMatFiles folder in: %s\n', validFolders{i});
                fprintf('  Contains %d .mat files\n', length(matFiles));
            end
        end
    end
    
    if hasExpMatFiles
        % Get list of all spike files to create experiment mat files for each one
        allSpikeFiles = {};
        for i = 1:length(validFolders)
            spikeFolder = fullfile(validFolders{i}, '1_SpikeDetection', '1A_SpikeDetectedData');
            if exist(spikeFolder, 'dir')
                spikeFiles = dir(fullfile(spikeFolder, '*_spikes.mat'));
                for j = 1:length(spikeFiles)
                    [~, recordingName, ~] = fileparts(spikeFiles(j).name);
                    recordingName = regexprep(recordingName, '_spikes$', ''); % Remove _spikes suffix
                    allSpikeFiles{end+1} = recordingName;
                end
            end
        end
        
        % Remove duplicates
        allSpikeFiles = unique(allSpikeFiles);
        
        % Create placeholder .mat files for each recording
        expFileCounter = 0;
        
        if options.verbose
            fprintf('  Creating %d experiment mat files\n', length(allSpikeFiles));
        end
        
        for i = 1:length(allSpikeFiles)
            recordingName = allSpikeFiles{i};
            outputMatFile = fullfile(experimentMatFolder, [recordingName '_' outputFolderName '.mat']);
            
            % Check if we can find a matching experiment file in any of the source folders
            sourceMatFile = '';
            sourceInfo = [];
            
            for j = 1:length(validFolders)
                sourceExpFolder = fullfile(validFolders{j}, 'ExperimentMatFiles');
                if exist(sourceExpFolder, 'dir')
                    % Look for files matching this recording name
                    expFiles = dir(fullfile(sourceExpFolder, [recordingName '_*.mat']));
                    if ~isempty(expFiles)
                        sourceMatFile = fullfile(sourceExpFolder, expFiles(1).name);
                        try
                            sourceData = load(sourceMatFile);
                            if isfield(sourceData, 'Info')
                                sourceInfo = sourceData.Info;
                                break; % Found it, exit loop
                            end
                        catch
                            % Continue to next folder
                        end
                    end
                end
            end
            
            % If we found a source, copy the Info structure
            if ~isempty(sourceInfo)
                % Update Info fields for the merged output
                Info = sourceInfo;
                Info.createdBy = 'mergeDIVs';
                Info.dateCreated = datestr(now);
                
                % Save the file
                save(outputMatFile, 'Info');
                expFileCounter = expFileCounter + 1;
            else
                % Create a new Info struct with basic information
                
                % Check if we can extract DIV and group info from the filename
                divMatch = regexp(recordingName, '(DIV|div)(\d+)', 'tokens', 'once');
                if ~isempty(divMatch)
                    divValue = str2double(divMatch{2});
                else
                    divValue = 0; % Default if DIV not found
                end
                
                % Try to get group from pattern like NGN2_DIV38_A1
                groupMatch = regexp(recordingName, '_([A-Z])(\d+)', 'tokens', 'once');
                if ~isempty(groupMatch)
                    groupValue = groupMatch{1};
                else
                    groupValue = 'unknown'; % Default group
                end
                
                % Create a proper Info struct with the fields expected by MEA-NAP
                Info = struct();
                Info.FN = {recordingName};
                Info.DIV = {divValue};
                Info.Grp = {groupValue};
                Info.createdBy = 'mergeDIVs';
                Info.dateCreated = datestr(now);
                
                % Save the file
                save(outputMatFile, 'Info');
                expFileCounter = expFileCounter + 1;
            end
        end
        
        if options.verbose
            fprintf('✓ Created %d experiment mat files\n', expFileCounter);
        end
    else
        if options.verbose
            fprintf('No ExperimentMatFiles folders found in any input folder.\n');
        end
    end
end

%% Completion message
if options.verbose
    fprintf('\n=================================================\n');
    fprintf('MEA-NAP DIV Spike Data Merger - COMPLETE\n');
    fprintf('=================================================\n\n');
    fprintf('Successfully merged %d DIV folders into: %s\n\n', length(validFolders), outputFolder);
    fprintf('Merged data can now be used for further MEA-NAP analysis steps\n');
    fprintf('such as neuronal activity, edge thresholding, and network activity\n');
    fprintf('by using this folder as input for the MEApipeline.m function.\n\n');
    
    % Display command to run pipeline on merged data
    paramFilePath = fullfile(outputFolder, ['Parameters_' outputFolderName '.mat']);
    fprintf('To run MEApipeline on this merged data, use the following command:\n');
    fprintf('  MEApipeline(''%s'')\n\n', paramFilePath);
end
end