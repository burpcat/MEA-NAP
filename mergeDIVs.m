function mergeDIVs(divFolders, outputFolder, varargin)
%% MERGEDIVS Merge spike data from multiple DIV output folders
%
% This function merges spike detection results from multiple DIV output folders
% generated by MEA-NAP pipeline. It focuses specifically on combining data after 
% Step 1 (spike detection) to enable further analysis of developmental trajectories.
%
% USAGE:
%   mergeDIVs(divFolders, outputFolder)
%   mergeDIVs(divFolders, outputFolder, options)
%
% INPUTS:
%   divFolders      - Cell array of strings with paths to DIV folders
%   outputFolder    - String, path to save the merged output
%   options         - (Optional) Struct with the following possible fields:
%       .overwrite          - Logical, whether to overwrite existing output (default: false)
%       .verbose            - Logical, whether to display detailed information (default: true)
%       .mergeExperiments   - Logical, whether to merge experiment mat files (default: true)
%       .copySpikes         - Logical, whether to copy spike files (default: true)
%       .mergeDivCSVs       - Logical, whether to merge DIV CSV files (default: true)
%
% OUTPUTS:
%   Creates a merged output folder containing:
%   - Combined spike detection data
%   - Merged DIV CSV file
%   - Unified parameter files
%   - Experiment mat files
%
% This function assumes that all input folders contain spike detection results
% from MEA-NAP and that the recordings were made on the same type of MEA grid.
%
% EXAMPLES:
%   % Merge two DIV folders
%   divFolders = {'/path/to/DIV5/div5', '/path/to/DIV10/div10'};
%   outputFolder = '/path/to/output/MergedDIVs';
%   mergeDIVs(divFolders, outputFolder);
%
%   % Merge with custom options
%   options.overwrite = true;
%   options.verbose = true;
%   mergeDIVs(divFolders, outputFolder, options);
%
% Author: Generated with Claude Code
% Date: March 2025

%% Parse input arguments
if nargin < 2
    error('Not enough input arguments. At least divFolders and outputFolder must be specified.');
end

% Set default options
options = struct(...
    'overwrite', false, ...
    'verbose', true, ...
    'mergeExperiments', true, ...
    'copySpikes', true, ...
    'mergeDivCSVs', true);

% Override defaults with user specified options
if nargin > 2
    userOptions = varargin{1};
    if ~isstruct(userOptions)
        error('Options must be provided as a struct.');
    end
    
    fields = fieldnames(userOptions);
    for i = 1:length(fields)
        if isfield(options, fields{i})
            options.(fields{i}) = userOptions.(fields{i});
        else
            warning('Unknown option: %s', fields{i});
        end
    end
end

% Ensure divFolders is a cell array
if ~iscell(divFolders)
    divFolders = {divFolders};
end

%% Initial validation
% Display function header
if options.verbose
    fprintf('=================================================\n');
    fprintf('MEA-NAP DIV Spike Data Merger\n');
    fprintf('=================================================\n\n');
    fprintf('Starting merge of %d DIV folders...\n', length(divFolders));
end

% Check if output folder exists
if exist(outputFolder, 'dir')
    if ~options.overwrite
        error('Output folder already exists. Use options.overwrite=true to overwrite.');
    elseif options.verbose
        fprintf('Output folder exists and will be overwritten.\n');
    end
else
    % Create output folder
    if options.verbose
        fprintf('Creating output folder: %s\n', outputFolder);
    end
    mkdir(outputFolder);
end

% Validate input folders
validFolders = {};
divNumbers = zeros(1, length(divFolders));

for i = 1:length(divFolders)
    % Check if folder exists
    if ~exist(divFolders{i}, 'dir')
        warning('Folder does not exist: %s - skipping', divFolders{i});
        continue;
    end
    
    % Check for spike detection folder
    spikeFolder = fullfile(divFolders{i}, '1_SpikeDetection');
    spikeDataFolder = fullfile(spikeFolder, '1A_SpikeDetectedData');
    if ~exist(spikeDataFolder, 'dir')
        warning('No spike data folder found in: %s - skipping', divFolders{i});
        continue;
    end
    
    % Check for parameter file
    paramFiles = dir(fullfile(divFolders{i}, 'Parameters_*.mat'));
    if isempty(paramFiles)
        warning('No parameter file found in: %s - skipping', divFolders{i});
        continue;
    end
    
    % Try to extract DIV number from folder name or DIV CSV file
    divCSV = dir(fullfile(divFolders{i}, 'div*.csv'));
    if ~isempty(divCSV)
        % Extract DIV number from CSV filename
        divMatch = regexp(divCSV(1).name, 'div(\d+)', 'tokens');
        if ~isempty(divMatch) && ~isempty(divMatch{1})
            divNumbers(i) = str2double(divMatch{1}{1});
        else
            % Try to extract from folder name
            [~, folderName] = fileparts(divFolders{i});
            divMatch = regexp(folderName, '(DIV|div)(\d+)', 'tokens');
            if ~isempty(divMatch) && ~isempty(divMatch{1})
                if length(divMatch{1}) > 1
                    divNumbers(i) = str2double(divMatch{1}{2}); % Get the number part
                else
                    divNumbers(i) = str2double(regexprep(divMatch{1}{1}, 'DIV|div', ''));
                end
            else
                divNumbers(i) = i; % Default sequential numbering
            end
        end
    else
        % Try folder name if no CSV
        [~, folderName] = fileparts(divFolders{i});
        divMatch = regexp(folderName, '(DIV|div)(\d+)', 'tokens');
        if ~isempty(divMatch) && ~isempty(divMatch{1})
            if length(divMatch{1}) > 1
                divNumbers(i) = str2double(divMatch{1}{2}); % Get the number part
            else
                divNumbers(i) = str2double(regexprep(divMatch{1}{1}, 'DIV|div', ''));
            end
        else
            divNumbers(i) = i; % Default sequential numbering
        end
    end
    
    validFolders{end+1} = divFolders{i};
    if options.verbose
        fprintf('✓ Validated folder: %s (DIV %d)\n', divFolders{i}, divNumbers(i));
    end
end

% Check if we have any valid folders
if isempty(validFolders)
    error('No valid DIV folders found. Please check your input folders.');
end

% Sort folders by DIV number
[divNumbers, sortIdx] = sort(divNumbers(1:length(validFolders)));
validFolders = validFolders(sortIdx);

if options.verbose
    fprintf('\nProcessing folders in DIV order:\n');
    for i = 1:length(validFolders)
        fprintf('  DIV %d: %s\n', divNumbers(i), validFolders{i});
    end
    fprintf('\n');
end

%% Create output folder structure
% Create spike detection folders
spikeOutputFolder = fullfile(outputFolder, '1_SpikeDetection');
spikeDataOutputFolder = fullfile(spikeOutputFolder, '1A_SpikeDetectedData');
spikeChecksOutputFolder = fullfile(spikeOutputFolder, '1B_SpikeDetectionChecks');

if ~exist(spikeOutputFolder, 'dir')
    mkdir(spikeOutputFolder);
end
if ~exist(spikeDataOutputFolder, 'dir')
    mkdir(spikeDataOutputFolder);
end
if ~exist(spikeChecksOutputFolder, 'dir')
    mkdir(spikeChecksOutputFolder);
end

% Create ExperimentMatFiles folder
experimentMatFolder = fullfile(outputFolder, 'ExperimentMatFiles');
if ~exist(experimentMatFolder, 'dir')
    mkdir(experimentMatFolder);
end

%% Copy spike data files
if options.copySpikes
    if options.verbose
        fprintf('Copying spike data files...\n');
    end
    
    spikeFileCounter = 0;
    
    for i = 1:length(validFolders)
        sourceFolder = fullfile(validFolders{i}, '1_SpikeDetection', '1A_SpikeDetectedData');
        spikeFiles = dir(fullfile(sourceFolder, '*_spikes.mat'));
        
        for j = 1:length(spikeFiles)
            copyfile(fullfile(sourceFolder, spikeFiles(j).name), ...
                    fullfile(spikeDataOutputFolder, spikeFiles(j).name));
            spikeFileCounter = spikeFileCounter + 1;
        end
        
        % Also copy spike detection check folders if they exist
        sourceChecksFolder = fullfile(validFolders{i}, '1_SpikeDetection', '1B_SpikeDetectionChecks');
        if exist(sourceChecksFolder, 'dir')
            % Get all subdirectories (group folders)
            groupFolders = dir(sourceChecksFolder);
            groupFolders = groupFolders([groupFolders.isdir]);
            groupFolders = groupFolders(~ismember({groupFolders.name}, {'.', '..'}));
            
            for j = 1:length(groupFolders)
                groupName = groupFolders(j).name;
                targetGroupFolder = fullfile(spikeChecksOutputFolder, groupName);
                
                if ~exist(targetGroupFolder, 'dir')
                    mkdir(targetGroupFolder);
                end
                
                % Copy recording folders for this group
                recordingFolders = dir(fullfile(sourceChecksFolder, groupName));
                recordingFolders = recordingFolders([recordingFolders.isdir]);
                recordingFolders = recordingFolders(~ismember({recordingFolders.name}, {'.', '..'}));
                
                for k = 1:length(recordingFolders)
                    recordingName = recordingFolders(k).name;
                    sourceRecFolder = fullfile(sourceChecksFolder, groupName, recordingName);
                    targetRecFolder = fullfile(spikeChecksOutputFolder, groupName, recordingName);
                    
                    if ~exist(targetRecFolder, 'dir')
                        mkdir(targetRecFolder);
                        
                        % Copy all check images
                        copyfile(fullfile(sourceRecFolder, '*.png'), targetRecFolder);
                    end
                end
            end
        end
    end
    
    if options.verbose
        fprintf('✓ Copied %d spike data files\n', spikeFileCounter);
    end
end

%% Merge DIV CSV files
if options.mergeDivCSVs
    if options.verbose
        fprintf('\nMerging DIV CSV files...\n');
    end
    
    % Collect all CSV data
    allCSVData = {};
    for i = 1:length(validFolders)
        divCSV = dir(fullfile(validFolders{i}, 'div*.csv'));
        if ~isempty(divCSV)
            try
                data = readtable(fullfile(validFolders{i}, divCSV(1).name));
                
                % Add DIV column if not present
                if ~any(strcmpi(data.Properties.VariableNames, 'DIV'))
                    if divNumbers(i) > 0
                        data.DIV = repmat(divNumbers(i), height(data), 1);
                    end
                end
                
                allCSVData{end+1} = data;
            catch ME
                warning('Error reading CSV file %s: %s', divCSV(1).name, ME.message);
            end
        end
    end
    
    % Combine all tables
    if ~isempty(allCSVData)
        % Find common column names across all tables
        allVarNames = cellfun(@(x) x.Properties.VariableNames, allCSVData, 'UniformOutput', false);
        commonVarNames = allVarNames{1};
        
        for i = 2:length(allVarNames)
            commonVarNames = intersect(commonVarNames, allVarNames{i});
        end
        
        % Select only common columns
        for i = 1:length(allCSVData)
            allCSVData{i} = allCSVData{i}(:, commonVarNames);
        end
        
        % Combine tables
        combinedCSV = vertcat(allCSVData{:});
        
        % Sort by DIV if present
        if any(strcmpi(combinedCSV.Properties.VariableNames, 'DIV'))
            combinedCSV = sortrows(combinedCSV, 'DIV');
        end
        
        % Generate output filename - use "div" + DIV numbers for naming
        [~, outputName] = fileparts(outputFolder);
        if isempty(outputName)
            outputName = 'MergedDIVs';
        end
        
        % Use consistent naming convention for the div CSV file
        csvOutputFile = fullfile(outputFolder, 'div_merged.csv');
        
        % Check if we need to match the original folder's CSV header format
        % First check if we can find the format from any source folder
        originalHeaderFormat = 'standard'; % Default format
        for i = 1:length(validFolders)
            divCSV = dir(fullfile(validFolders{i}, 'div*.csv'));
            if ~isempty(divCSV)
                try
                    % Read first line to get header
                    fid = fopen(fullfile(validFolders{i}, divCSV(1).name), 'r');
                    if fid ~= -1
                        headerLine = fgetl(fid);
                        fclose(fid);
                        
                        % Check header format
                        if contains(headerLine, 'Recording filename')
                            originalHeaderFormat = 'recording_format';
                            break;
                        end
                    end
                catch
                    % If error, continue with next folder
                    if fid ~= -1
                        fclose(fid);
                    end
                end
            end
        end
        
        % Handle different formats based on detected format
        if strcmp(originalHeaderFormat, 'recording_format')
            % This matches the merger3855_nap format with "Recording filename,DIV group,Genotype,Ground"
            % The columns are already in the right order, just need to rename
            combinedCSV.Properties.VariableNames{1} = 'Recording filename';
            combinedCSV.Properties.VariableNames{2} = 'DIV';
            combinedCSV.Properties.VariableNames{3} = 'group';
            if any(strcmpi(combinedCSV.Properties.VariableNames, 'ground'))
                combinedCSV.Properties.VariableNames{strcmpi(combinedCSV.Properties.VariableNames, 'ground')} = 'Ground';
            else
                combinedCSV.Ground = repmat({''},height(combinedCSV),1);
            end
            
            % Set Genotype column if it exists
            if any(strcmpi(combinedCSV.Properties.VariableNames, 'Genotype'))
                % Already has Genotype column
            elseif any(strcmpi(combinedCSV.Properties.VariableNames, 'group'))
                % Use group as Genotype
                columnIdx = find(strcmpi(combinedCSV.Properties.VariableNames, 'group'));
                combinedCSV.Properties.VariableNames{columnIdx} = 'Genotype';
            end
            
            % Reorder columns to match expected format
            expectedCols = {'Recording filename', 'DIV', 'Genotype', 'Ground'};
            availableCols = intersect(expectedCols, combinedCSV.Properties.VariableNames, 'stable');
            otherCols = setdiff(combinedCSV.Properties.VariableNames, expectedCols, 'stable');
            combinedCSV = combinedCSV(:, [availableCols, otherCols]);
        else
            % Standard format with filename, DIV, group, ground
            if ~any(strcmpi(combinedCSV.Properties.VariableNames, 'ground'))
                combinedCSV.ground = repmat({''},height(combinedCSV),1);
            end
            
            % Reorder columns
            orderedCols = {'filename', 'DIV', 'group', 'ground'};
            availableCols = intersect(orderedCols, combinedCSV.Properties.VariableNames, 'stable');
            otherCols = setdiff(combinedCSV.Properties.VariableNames, orderedCols, 'stable');
            combinedCSV = combinedCSV(:, [availableCols, otherCols]);
            
            % Rename columns if needed to match expected names
            targetNames = {'filename', 'DIV', 'group', 'ground'};
            currentNames = combinedCSV.Properties.VariableNames(1:min(4,width(combinedCSV)));
            for i = 1:length(currentNames)
                if ~strcmpi(currentNames{i}, targetNames{i})
                    combinedCSV.Properties.VariableNames{i} = targetNames{i};
                end
            end
            
            % Add RecordingFilename column if it doesn't exist
            if ~any(strcmpi(combinedCSV.Properties.VariableNames, 'RecordingFilename'))
                % Try to extract recording name from filename
                if any(strcmpi(combinedCSV.Properties.VariableNames, 'filename'))
                    combinedCSV.RecordingFilename = combinedCSV.filename;
                end
            end
        end
        
        % Write to CSV
        writetable(combinedCSV, csvOutputFile);
        
        if options.verbose
            fprintf('✓ Created merged CSV file: %s\n', csvOutputFile);
            fprintf('  Contains %d recordings across %d DIV timepoints\n', ...
                height(combinedCSV), length(unique(combinedCSV.DIV)));
        end
    else
        warning('No DIV CSV files found to merge.');
    end
end

%% Merge parameter files
if options.verbose
    fprintf('\nMerging parameter files...\n');
end

% Collect parameters from all valid folders
paramStructs = cell(1, length(validFolders));
paramFileNames = cell(1, length(validFolders));
for i = 1:length(validFolders)
    paramFiles = dir(fullfile(validFolders{i}, 'Parameters_*.mat'));
    if ~isempty(paramFiles)
        try
            % Load the first parameter file found
            paramFileNames{i} = paramFiles(1).name;
            paramData = load(fullfile(validFolders{i}, paramFiles(1).name));
            if isfield(paramData, 'Params')
                paramStructs{i} = paramData.Params;
            else
                % Try to find the parameter struct
                fields = fieldnames(paramData);
                for j = 1:length(fields)
                    if isstruct(paramData.(fields{j}))
                        paramStructs{i} = paramData.(fields{j});
                        break;
                    end
                end
            end
        catch ME
            warning('Error loading parameter file from %s: %s', validFolders{i}, ME.message);
            paramStructs{i} = [];
            paramFileNames{i} = '';
        end
    else
        paramStructs{i} = [];
        paramFileNames{i} = '';
    end
end

% Remove empty parameter structs
validIndices = ~cellfun(@isempty, paramStructs);
paramStructs = paramStructs(validIndices);
paramFileNames = paramFileNames(validIndices);

if ~isempty(paramStructs)
    % Choose the most complete parameter set
    paramFieldCounts = cellfun(@(x) numel(fieldnames(x)), paramStructs);
    [~, mostCompleteIdx] = max(paramFieldCounts);
    mergedParams = paramStructs{mostCompleteIdx};
    
    % Update paths
    mergedParams.outputDataFolder = outputFolder;
    
    % Check if we should use specific suffix from an existing parameter file
    [~, outputFolderName] = fileparts(outputFolder);
    if isempty(outputFolderName)
        outputFolderName = 'MergedDIVs';
    end
    
    % Check if we should preserve suffix from existing parameter files
    suffixToUse = '_nap'; % Default suffix
    for i = 1:length(paramFileNames)
        % Check if the parameter file has a consistent naming pattern
        paramNameMatch = regexp(paramFileNames{i}, 'Parameters_(.+)\.mat', 'tokens');
        if ~isempty(paramNameMatch) && ~isempty(paramNameMatch{1})
            existingSuffix = paramNameMatch{1}{1};
            
            % If suffix ends with "_nap", use that exact pattern
            if endsWith(existingSuffix, '_nap')
                % Check if this suffix also contains the output folder name
                folderNamePattern = [outputFolderName '_nap'];
                if contains(existingSuffix, outputFolderName)
                    suffixToUse = existingSuffix;
                    break;
                else
                    suffixToUse = [outputFolderName '_nap'];
                end
            end
        end
    end
    
    mergedParams.outputDataFolderName = outputFolderName;
    
    % Update DIV information
    mergedParams.DivNm = divNumbers;
    
    % Save merged parameters with the determined suffix
    paramMatFile = fullfile(outputFolder, ['Parameters_' suffixToUse '.mat']);
    paramCSVFile = fullfile(outputFolder, ['Parameters_' suffixToUse '.csv']);
    
    % Save MAT file
    Params = mergedParams; % Must use this variable name for compatibility
    save(paramMatFile, 'Params');
    
    % Create parameter CSV
    paramNames = fieldnames(mergedParams);
    paramValues = cell(length(paramNames), 1);
    
    for i = 1:length(paramNames)
        val = mergedParams.(paramNames{i});
        if isempty(val)
            paramValues{i} = '';
        elseif ischar(val)
            paramValues{i} = val;
        elseif isnumeric(val) && isscalar(val)
            paramValues{i} = num2str(val);
        elseif iscell(val)
            % Try to convert cell to string representation safely
            try
                % Check if all elements are strings
                allChars = true;
                for j = 1:numel(val)
                    if ~ischar(val{j}) && ~isstring(val{j})
                        allChars = false;
                        break;
                    end
                end
                
                if allChars
                    paramValues{i} = strjoin(val, ', ');
                else
                    paramValues{i} = '<cell array>';
                end
            catch
                paramValues{i} = '<cell array>';
            end
        elseif isnumeric(val) && ~isscalar(val)
            paramValues{i} = ['[' strjoin(arrayfun(@num2str, val, 'UniformOutput', false), ', ') ']'];
        else
            paramValues{i} = '<complex data>';
        end
    end
    
    paramTable = table(paramNames, paramValues, 'VariableNames', {'Parameter', 'Value'});
    writetable(paramTable, paramCSVFile);
    
    if options.verbose
        fprintf('✓ Created merged parameter files:\n');
        fprintf('  MAT file: %s\n', paramMatFile);
        fprintf('  CSV file: %s\n', paramCSVFile);
    end
else
    warning('No parameter files found to merge.');
end

%% Copy channel layout file
% Copy the first available channel_layout.png file
for i = 1:length(validFolders)
    layoutFile = fullfile(validFolders{i}, 'channel_layout.png');
    if exist(layoutFile, 'file')
        copyfile(layoutFile, fullfile(outputFolder, 'channel_layout.png'));
        if options.verbose
            fprintf('✓ Copied channel layout file\n');
        end
        break;
    end
end

%% Create experiment mat files
if options.mergeExperiments
    if options.verbose
        fprintf('\nCreating experiment mat files...\n');
    end
    
    % First check if source folders have ExperimentMatFiles and determine naming pattern
    hasExpMatFiles = false;
    matFileSuffix = '_nap';  % Default suffix
    
    for i = 1:length(validFolders)
        sourceExpFolder = fullfile(validFolders{i}, 'ExperimentMatFiles');
        if exist(sourceExpFolder, 'dir')
            hasExpMatFiles = true;
            matFiles = dir(fullfile(sourceExpFolder, '*.mat'));
            
            if options.verbose
                fprintf('  Found ExperimentMatFiles folder in: %s\n', validFolders{i});
                fprintf('  Contains %d .mat files\n', length(matFiles));
            end
            
            % Try to extract suffix pattern from existing files
            if ~isempty(matFiles)
                for j = 1:min(5, length(matFiles))  % Check up to 5 files for pattern
                    [~, fileName, ~] = fileparts(matFiles(j).name);
                    % Get pattern after recording name
                    parts = strsplit(fileName, '_');
                    if length(parts) >= 3  % Assuming format like NGN2_DIV38_A1_suffix.mat
                        potentialSuffix = parts{end};
                        if strcmp(potentialSuffix, 'nap') || endsWith(potentialSuffix, '_nap')
                            % Found a pattern like merger3855_nap
                            for k = length(parts)-1:-1:2  % Check if there are more parts to the suffix
                                testSuffix = [parts{k} '_' potentialSuffix];
                                if any(cellfun(@(x) endsWith(x, ['_' testSuffix]), {matFiles.name}))
                                    potentialSuffix = testSuffix;
                                else
                                    break;
                                end
                            end
                            matFileSuffix = potentialSuffix;
                            if options.verbose
                                fprintf('  Found suffix pattern: %s\n', matFileSuffix);
                            end
                            break;
                        end
                    end
                end
            end
        else
            if options.verbose
                fprintf('  No ExperimentMatFiles folder found in: %s\n', validFolders{i});
            end
        end
    end
    
    % Get output folder name for file naming
    [~, outputFolderName] = fileparts(outputFolder);
    if isempty(outputFolderName)
        outputFolderName = 'merger_unknown';
    end
    
    % Use the original suffix if found, otherwise use outputFolderName_nap
    if ~strcmp(matFileSuffix, '_nap')
        finalSuffix = matFileSuffix;
    else
        finalSuffix = [outputFolderName '_nap'];
    end
    
    % Get list of all spike files to create experiment mat files for each one
    allSpikeFiles = {};
    for i = 1:length(validFolders)
        spikeFolder = fullfile(validFolders{i}, '1_SpikeDetection', '1A_SpikeDetectedData');
        if exist(spikeFolder, 'dir')
            spikeFiles = dir(fullfile(spikeFolder, '*_spikes.mat'));
            for j = 1:length(spikeFiles)
                [~, recordingName, ~] = fileparts(spikeFiles(j).name);
                recordingName = regexprep(recordingName, '_spikes$', ''); % Remove _spikes suffix
                allSpikeFiles{end+1} = recordingName;
            end
        end
    end
    
    % Remove duplicates
    allSpikeFiles = unique(allSpikeFiles);
    
    % Create placeholder .mat files for each recording
    expFileCounter = 0;
    
    if options.verbose
        fprintf('  Creating %d placeholder experiment mat files\n', length(allSpikeFiles));
    end
    
    for i = 1:length(allSpikeFiles)
        recordingName = allSpikeFiles{i};
        outputMatFile = fullfile(experimentMatFolder, [recordingName '_' finalSuffix '.mat']);
        
        % Create a minimal placeholder struct with metadata
        % This contains just enough to indicate this file was processed
        expInfo = struct();
        expInfo.recording = recordingName;
        expInfo.createdBy = 'mergeDIVs';
        expInfo.dateCreated = datestr(now);
        expInfo.placeholder = true;
        
        % Save the placeholder file
        save(outputMatFile, 'expInfo');
        expFileCounter = expFileCounter + 1;
    end
    
    if options.verbose
        fprintf('✓ Created %d experiment mat files\n', expFileCounter);
    end
end

%% Completion message
if options.verbose
    fprintf('\n=================================================\n');
    fprintf('MEA-NAP DIV Spike Data Merger - COMPLETE\n');
    fprintf('=================================================\n\n');
    fprintf('Successfully merged %d DIV folders into: %s\n\n', length(validFolders), outputFolder);
    fprintf('Merged data can now be used for further MEA-NAP analysis steps\n');
    fprintf('such as neuronal activity, edge thresholding, and network activity\n');
    fprintf('by using this folder as input for the MEApipeline.m function.\n\n');
end

end

% Helper function to extract a DIV number from a folder name
function divNum = extractDIVNumber(folderPath)
[~, folderName] = fileparts(folderPath);

% Try to match DIV followed by number
divMatch = regexp(folderName, '(DIV|div)(\d+)', 'tokens');
if ~isempty(divMatch) && ~isempty(divMatch{1})
    if length(divMatch{1}) > 1
        divNum = str2double(divMatch{1}{2}); % Get the number part
    else
        divNum = str2double(regexprep(divMatch{1}{1}, 'DIV|div', ''));
    end
else
    divNum = 0; % Could not determine DIV number
end
end